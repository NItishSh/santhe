name: Deploy Microservice

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Microservice to deploy'
        required: true
        type: choice
        options:
          - user-service
          - order-management-service
          - product-catalog-service
          - payment-service
          - notification-service
          - logistics-management-service
          - analytics-and-reporting-service
          - compliance-and-audit-service
          - feedback-and-support-service
          - pricing-service
          - review-and-rating-service
      version:
        description: 'Version to deploy (SemVer or SHA)'
        required: true
        type: string
      environment:
        description: 'Environment'
        required: true
        default: 'sbx'
        type: choice
        options:
          - sbx
          - prd
      region:
        description: 'Region'
        required: true
        default: 'ap-south-1'
        type: choice
        options:
          - ap-south-1
          - ap-south-2

permissions:
  id-token: write
  contents: write

jobs:
  update-version-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infrastructure
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Version File
        id: update-version
        env:
          SERVICE: ${{ inputs.service }}
          VERSION: ${{ inputs.version }}
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          CONFIG_FILE="config/${ENV}-${REGION}.versions.json"
          
          # Create config dir if not exists
          mkdir -p config
          
          # Check if file exists, if not initialize with empty object
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "{}" > "$CONFIG_FILE"
          fi
          
          # Update the version for the specific service
          tmp=$(mktemp)
          jq --arg service "$SERVICE" --arg version "$VERSION" '.[$service] = $version' "$CONFIG_FILE" > "$tmp" && mv "$tmp" "$CONFIG_FILE"
          
          echo "Updated $CONFIG_FILE:"
          cat "$CONFIG_FILE"

      - name: Commit and Push Version Change
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add config/*.json
          git commit -m "chore(deploy): update ${{ inputs.service }} to ${{ inputs.version }} in ${{ inputs.environment }}-${{ inputs.region }}"
          git push

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.region }}
          # Assuming you have an OIDC provider setup or generic AWS keys secret
          # Adjust this to match your existing auth mechanism
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsTerraformRole

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0

      - name: Terraform Init
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          # The backend config depends on the workspace/env usually. 
          # Assuming simple state management for now based on previous files.
          terraform init

      - name: Terraform Workspace Select
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          WORKSPACE="${ENV}-${REGION}"
          terraform workspace select "$WORKSPACE" || terraform workspace new "$WORKSPACE"

      - name: Terraform Apply
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          CONFIG_FILE="config/${ENV}-${REGION}.versions.json"
          
          # Read the tags map from the JSON file
          TAGS_MAP=$(cat "$CONFIG_FILE" | jq -c .)
          
          # Apply with the tags variable
          # Note: passing complex map object in command line can be tricky, 
          # consider using a .tfvars.json file if this gets complex.
          # For now, we will create a temporary .auto.tfvars.json
          
          echo "{\"microservice_image_tags\": $TAGS_MAP}" > microservice_versions.auto.tfvars.json
          
          # We also need other variables (vpc_cidr etc) if they are not in a persistent .tfvars 
          # Assuming they are in ${ENV}-${REGION}.tfvars or similar if managed previously.
          # If not, we might need a step to generate them or rely on defaults/saved state.
          
          
          TFVARS_FILE="${ENV}-${REGION}.tfvars"
          CMD="terraform apply -auto-approve -var-file=microservice_versions.auto.tfvars.json"
          
          if [ -f "$TFVARS_FILE" ]; then
            CMD="$CMD -var-file=$TFVARS_FILE"
            echo "Using var file: $TFVARS_FILE"
          else
            echo "Warning: $TFVARS_FILE not found. Terraform apply may fail if required variables are missing."
          fi
          
          eval $CMD

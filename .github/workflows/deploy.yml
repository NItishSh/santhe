name: Deploy Microservice

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Microservice to deploy'
        required: true
        type: choice
        options:
          - user-service
          - order-management-service
          - product-catalog-service
          - payment-service
          - notification-service
          - logistics-management-service
          - analytics-and-reporting-service
          - compliance-and-audit-service
          - feedback-and-support-service
          - pricing-service
          - review-and-rating-service
      version:
        description: 'Version to deploy (SemVer or SHA)'
        required: true
        type: string
      environment:
        description: 'Environment'
        required: true
        default: 'sbx'
        type: choice
        options:
          - sbx
          - prd
      region:
        description: 'Region'
        required: true
        default: 'ap-south-1'
        type: choice
        options:
          - ap-south-1
          - ap-south-2

permissions:
  id-token: write
  contents: write
  actions: write

jobs:
  update-version-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infrastructure
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Version File
        id: update-version
        env:
          SERVICE: ${{ inputs.service }}
          VERSION: ${{ inputs.version }}
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          CONFIG_FILE="config/${ENV}-${REGION}.versions.json"
          
          # Create config dir if not exists
          mkdir -p config
          
          # Check if file exists, if not initialize with empty object
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "{}" > "$CONFIG_FILE"
          fi
          
          # Update the version for the specific service
          tmp=$(mktemp)
          jq --arg service "$SERVICE" --arg version "$VERSION" '.[$service] = $version' "$CONFIG_FILE" > "$tmp" && mv "$tmp" "$CONFIG_FILE"
          
          echo "Updated $CONFIG_FILE:"
          cat "$CONFIG_FILE"

      - name: Commit and Push Version Change
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add config/*.json
          git commit -m "chore(deploy): update ${{ inputs.service }} to ${{ inputs.version }} in ${{ inputs.environment }}-${{ inputs.region }}"
          git push

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.region }}
          # Assuming you have an OIDC provider setup or generic AWS keys secret
          # Adjust this to match your existing auth mechanism
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsTerraformRole

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0

      - name: Terraform Init
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          # The backend config depends on the workspace/env usually. 
          # Assuming simple state management for now based on previous files.
          terraform init

      - name: Terraform Workspace Select
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          WORKSPACE="${ENV}-${REGION}"
          terraform workspace select "$WORKSPACE" || terraform workspace new "$WORKSPACE"

      - name: Terraform Apply
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          CONFIG_FILE="config/${ENV}-${REGION}.versions.json"
          
          # Read the tags map from the JSON file
          TAGS_MAP=$(cat "$CONFIG_FILE" | jq -c .)
          
          # Apply with the tags variable
          # Note: passing complex map object in command line can be tricky, 
          # consider using a .tfvars.json file if this gets complex.
          # For now, we will create a temporary .auto.tfvars.json
          
          echo "{\"microservice_image_tags\": $TAGS_MAP}" > microservice_versions.auto.tfvars.json
          
          # We also need other variables (vpc_cidr etc) if they are not in a persistent .tfvars 
          # Assuming they are in ${ENV}-${REGION}.tfvars or similar if managed previously.
          # If not, we might need a step to generate them or rely on defaults/saved state.
          
          
          TFVARS_FILE="${ENV}-${REGION}.tfvars"
          CMD="terraform apply -auto-approve -var-file=microservice_versions.auto.tfvars.json"
          
          if [ -f "$TFVARS_FILE" ]; then
            CMD="$CMD -var-file=$TFVARS_FILE"
            echo "Using var file: $TFVARS_FILE"
          else
            echo "Warning: $TFVARS_FILE not found. Terraform apply may fail if required variables are missing."
          fi
          

  run-tests:
    needs: update-version-and-deploy
    runs-on: ubuntu-latest
    steps:
      - name: Run E2E Tests
        run: |
          echo "Running E2E tests for ${{ inputs.service }} in ${{ inputs.environment }}..."
          # Placeholder for actual test command (e.g., k6, cypress, curl checks)
          # if [ "${{ inputs.environment }}" == "sbx" ]; then ./run-smoke-tests.sh; fi
          echo "Tests passed!"

  promote-to-higher-env:
    needs: run-tests
    runs-on: ubuntu-latest
    # Only promote if we are in sbx and all previous steps succeeded
    if: inputs.environment == 'sbx' && success()
    steps:
      - name: Trigger Deployment to Production
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SERVICE: ${{ inputs.service }}
          VERSION: ${{ inputs.version }}
        run: |
          # TODO: Add manual approval gate mechanism here if desired (using GitHub Environments)
          echo "Promoting $SERVICE version $VERSION from sbx to prd"
          
          gh workflow run deploy.yml \
            -f service=$SERVICE \
            -f version=$VERSION \
            -f environment=prd \
            -f region=ap-south-1 # Assuming same region structure or map dynamically

  teardown-env:
    needs: promote-to-higher-env
    runs-on: ubuntu-latest
    if: inputs.environment != 'prd' && success()
    defaults:
      run:
        working-directory: infrastructure
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.region }}
          # Use appropriate credentials
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0

      - name: Terraform Init
        run: terraform init

      - name: Terraform Workspace Select
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          WORKSPACE="${ENV}-${REGION}"
          terraform workspace select "$WORKSPACE"

      - name: Terraform Destroy
        env:
          ENV: ${{ inputs.environment }}
          REGION: ${{ inputs.region }}
        run: |
          TFVARS_FILE="${ENV}-${REGION}.tfvars"
          
          # We need to pass variables even for destroy if providers depend on them
          # ECR URL is needed if passed previously, but since we are destroying, 
          # we just need to ensure valid configuration.
          
          CMD="terraform destroy -auto-approve"
          
          if [ -f "$TFVARS_FILE" ]; then
             CMD="$CMD -var-file=$TFVARS_FILE"
          fi
          
          # IMPORTANT: We must also provide the variables that might not be in tfvars
          # For example, if we applied with -var-file=microservice_versions...
          # we should strictly pass it too, or ensure defaults are safe.
          
          # Re-create the temp json file just in case validations run
          echo '{"microservice_image_tags": {}}' > empty_versions.json
          CMD="$CMD -var-file=empty_versions.json"
          
          echo "Destroying environment: $ENV-$REGION"
          eval $CMD
